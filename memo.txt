Building a Reactive RESTful Web Service
    This guide walks you through the process of creating a "Hello, Spring!" RESTful web service with Spring WebFlux (new as of Spring Boot 2.0) and then consumes that service with a WebClient (also new as of Spring Boot 2.0).

    *This guide shows the functional way of using Spring WebFlux. You can also use annotations with WebFlux.

What You Will Build
    You will build a RESTful web service with Spring Webflux and a WebClient consumer of that service. You will be able to see output in both System.out and at:
        http://localhost:8080/hello

Github:
https://github.com/spring-guides/gs-reactive-rest-service

Initial dependency:
    Spring Reactive Web

1) Create a WebFlux Handler
   We’re going to start with a Greeting POJO that will be serialized as JSON by our RESTful service:

   In the Spring Reactive approach, we use a handler to handle the request and create a response, as shown in the following example:

   src/main/java/hello/GreetingHandler.java
   This simple reactive class always returns a JSON body with a “Hello, Spring!” greeting. It could return many other things, including a stream of items from a database, a stream of items that were generated by calculations, and so on. Note the reactive code: a Mono object that holds a ServerResponse body.

2) Create a Router
   In this application, we use a router to handle the only route we expose (/hello), as shown in the following example:
   src/main/java/hello/GreetingRouter.java

   The router listens for traffic on the /hello path and returns the value provided by our reactive handler class.

3) Create a WebClient
   The Spring RestTemplate class is, by nature, blocking.
   Consequently, we do not want to use it in a reactive application.
   For reactive applications, Spring offers the WebClient class, which is non-blocking.
   We use a WebClient-based implementation to consume our RESTful service:

   src/main/java/hello/GreetingClient.java

   The WebClient class uses reactive features, in the form of a Mono to hold the content of the message (returned by the getMessage method). This is using a function API, rather than an imperative one, to chain reactive operators.

   It can take time to get used to Reactive APIs, but the WebClient has interesting features and can also be used in traditional Spring MVC applications.

   *You can use WebClient to communicate with non-reactive, blocking services, too.


4) Make the Application Executable
   We’re going to use the main() method to drive our application and get the Greeting message from our endpoint.

   src/main/java/hello/Application.java

   @SpringBootApplication is a convenience annotation that adds all of the following:

   @Configuration: Tags the class as a source of bean definitions for the application context.

   @EnableAutoConfiguration: Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings. For example, if spring-webmvc is on the classpath, this annotation flags the application as a web application and activates key behaviors, such as setting up a DispatcherServlet.

   @ComponentScan: Tells Spring to look for other components, configurations, and services in the hello package, letting it find the controllers.

   The main() method uses Spring Boot’s SpringApplication.run() method to launch an application. Did you notice that there was not a single line of XML? There is no web.xml file, either. This web application is 100% pure Java and you did not have to deal with configuring any plumbing or infrastructure.

5) Build an executable JAR
   You can run the application
    Logging output is displayed. The service should be up and running within a few seconds.

    Once the service has started, you can see a line that reads:

    >> message = Hello, Spring!

    That line comes from the reactive content being consumed by the WebClient.
    Naturally, you can find something more interesting to do with your output than put it in System.out.

5) Test the Application
   Now that the application is running, you can test it. To start with, you can open a browser and go to http://localhost:8080/hello and see, “Hello, Spring!” For this guide, we also created a test class to get you started on testing with the WebTestClient class.

   src/test/java/hello/GreetingRouterTest.java
        {"message":"Hello, Spring!"}

6) Summary
   Congratulations!
   You have developed a Reactive Spring application that includes a WebClient to consume a RESTful service!

7) It works correctly !